'''
shapefiles generated by /NSHA2018/source_models/zones/get_NSHA18_mfds_fixed_b.py
'''

from os import path
import shapefile
from shapely.geometry import Point, Polygon
#from tools.nsha_tools import get_field_data, get_shp_centroid
from mapping_tools import distance, get_field_data, drawshapepoly, get_map_polygons, mask_outside_polygons, cpt2colormap
from numpy import nan, isnan, nanmean, arange, array, where, mean, percentile, interp, floor, mgrid, ogrid, ma
from mpl_toolkits.basemap import Basemap
from matplotlib import colors, colorbar, style
import matplotlib.pyplot as plt
from scipy.interpolate import griddata

###############################################################################
# set defaults
###############################################################################

degs = ['10', '8', '6', '4', '3', '2', '1']
degs = ['6', '4', '3', '2', '1']
basepath = '/Users/trev/Documents/Geoscience_Australia/NSHA2018/source_models/zones/2018_mw'

###############################################################################
# make grid
###############################################################################
'''
bbox = '107.0/153.0/-45.0/-7.0'

bbox = bbox.split('/')
minlon = float(bbox[0])
maxlon = float(bbox[1])
minlat = float(bbox[2])
maxlat = float(bbox[3])
mbuff_l = 1.
mbuff_r = 3.5
'''    
bbox = '110.0/156.0/-45.0/-9.0' # map boundary - lon1/lon2/lat1/lat2
bbox = bbox.split('/')
minlon = float(bbox[0])
maxlon = float(bbox[1])
minlat = float(bbox[2])
maxlat = float(bbox[3])
mbuff_l = 0
mbuff_r = 0

# make first grid
res = 0.5 # degrees
xrng = arange(minlon, maxlon+res, res)
yrng = arange(minlat, maxlat+res, res)

glons = []
glats = []
bvals = []
bsig = []
points = []
bdeg = []
for x in xrng:
    for y in yrng:
        glats.append(y)
        glons.append(x)
        bvals.append(nan)
        points.append([x, y])
        bdeg.append(nan)
        bsig.append(nan)
        
points = array(points)

###############################################################################
# loop thru shapfiles
###############################################################################

for deg in degs:
    
    # load shapefile
    #shppath = path.join(basepath, 'Gridded_'+deg+'D', 'shapefiles', 'Gridded_'+deg+'D_NSHA18.shp')
    shppath = path.join(basepath, 'Radial_'+deg+'D', 'shapefiles', 'Radial_'+deg+'D_NSHA18.shp')
    sf = shapefile.Reader(shppath)
    print(shppath)
    
    # get shapes
    shapes = sf.shapes()

    # get bvalue data
    shp_bvals = get_field_data(sf, 'BVAL_BEST', 'float')
    shp_bvals_low = get_field_data(sf, 'BVAL_LOWER', 'float')
    
    # loop through points
    for i in range(0, len(bvals)):
        poly_bvals = []
        poly_sigma = []
        in_poly = []
        point = Point(glons[i], glats[i])
        for shape, shp_b, shp_bs in zip(shapes, shp_bvals, shp_bvals_low):
            poly = Polygon(shape.points)
            
            # check if point in poly
            if point.within(poly) or point.touches(poly):
                 poly_bvals.append(shp_b)
                 poly_sigma.append(shp_bs)
                 
                 # check if in, or touching
                 if point.within(poly):
                     in_poly.append(1)
                 else:
                     in_poly.append(0)
        
        # get mean bval (overwrite coarser res)
        idx = where(array(poly_bvals) > 0)[0]
        if len(idx) > 0:
            bvals[i] = nanmean(array(poly_bvals))
            bdeg[i] = int(deg.strip('D'))
            bsig[i] = nanmean(array(poly_sigma)) - bvals[i]
            
        # now overwrite with only "within" polys
        idx = where((array(poly_bvals) > 0) & (array(in_poly) == 1))[0]
        if len(idx) > 0:
            bvals[i] = nanmean(array(poly_bvals)[idx])
            bsig[i]  = nanmean(array(poly_sigma)[idx]) - bvals[i]
       
###############################################################################
# map b-value
###############################################################################

# set figure
fig = plt.figure(1, figsize=(13, 9))

# set national-scale basemap
llcrnrlat = -45
urcrnrlat = -7
llcrnrlon = 105
urcrnrlon = 155
lon_0 = mean([llcrnrlon, urcrnrlon])
lat_1 = percentile([llcrnrlat, urcrnrlat], 25)
lat_2 = percentile([llcrnrlat, urcrnrlat], 75)

m = Basemap(llcrnrlon=llcrnrlon,llcrnrlat=llcrnrlat, \
            urcrnrlon=urcrnrlon,urcrnrlat=urcrnrlat,
            projection='lcc',lat_1=lat_1,lat_2=lat_2,lon_0=lon_0,
            resolution='l',area_thresh=1000.)

# annotate
m.drawcoastlines(linewidth=0.5,color='0.25', zorder=10000)
#m.fillcontinents(color='coral',lake_color='aqua')
m.drawcountries()
m.drawstates()
#m.fillcontinents(color='0.8', lake_color='1.0')
    
# draw parallels and meridians.
ll_space = 6
m.drawparallels(arange(-90.,90.,ll_space/2.0), labels=[1,0,0,0],fontsize=10, dashes=[2, 2], color='0.5', linewidth=0.5)
m.drawmeridians(arange(0.,360.,ll_space), labels=[0,0,0,1], fontsize=10, dashes=[2, 2], color='0.5', linewidth=0.5)

# get colour index
ncolours=8
b_min = 0.7
b_max = 1.5
cmap = plt.get_cmap('viridis_r', ncolours)
norm = colors.BoundaryNorm(boundaries=arange(b_min, b_max+0.1, 0.1), ncolors=ncolours)

'''
cindex = []

# loop thru b values
for b in bvals:
    if not isnan(b):
        idx = interp(b, [b_min, b_max], [0, ncolours-1])
        cindex.append(int(floor(idx)))
    else:
        cindex.append(-1)
    
# get cmap
cmap = plt.get_cmap('viridis_r', ncolours)
cs = (cmap(arange(ncolours)))

# plt data
for lo, la, b, ci in zip(lons, lats, bvals, cindex):
    if not ci == -1:
        col = [cs[ci][0],cs[ci][1],cs[ci][2]]
        x, y = m(lo, la)
        m.plot(x, y, 'o', ms=4, mec=col, mfc=col)
'''

###############################################################################
# map b-value
###############################################################################

print('Resampling data...')
N = 500j
extent = (minlon-mbuff_l, maxlon+mbuff_r, minlat-mbuff_r, maxlat+0)
xs,ys = mgrid[extent[0]:extent[1]:N, extent[2]:extent[3]:N]
	
resampled = griddata(points, bvals, (xs, ys), method='linear')

# get 1D lats and lons for map transform
lons = ogrid[extent[0]:extent[1]:N]
lats = ogrid[extent[2]:extent[3]:N]

# transform to map projection
nx = int((m.xmax-m.xmin)/3000.)+1
ny = int((m.ymax-m.ymin)/3000.)+1

transhaz = m.transform_scalar(resampled.T,lons,lats,nx,ny)

masked_array = ma.array(transhaz, mask=isnan(transhaz))

m.imshow(masked_array, cmap=cmap, extent=extent, norm=norm, zorder=0)

##########################################################################################
# get land & lake polygons for masking
##########################################################################################
# mask non-AU polygons
nonmask = [0, 5, 8, 10, 13, 14, 15, 16, 17, 20, 21] #, 2, 3, 4, 6, 7, 11, 13, 16, 17] # polygon number
landpolys = []
for pidx, polygon in enumerate(m.landpolygons):
    maskPoly = True
    for nmidx in nonmask:
        if pidx == nmidx:
            maskPoly = False 
    if maskPoly == True:
        poly = polygon.get_coords()
        plt.fill(poly[:,0], poly[:,1], 'w')
    
#mask_outside_polygon(polys[1][::-1], ax=None)
polys = get_map_polygons(m)
mask_outside_polygons(polys, '0.9', plt)

# get lake ploygons
polygons = []
for polygon in m.lakepolygons:
    poly = polygon.get_coords()
    plt.fill(poly[:,0], poly[:,1], '0.9')
    polygons.append(poly)

##########################################################################################
# finish off
##########################################################################################

# overlay domains
sf = shapefile.Reader('/Users/trev/Documents/Geoscience_Australia/NSHA2018/source_models/zones/shapefiles/Domains/Domains_Sep2011.shp')
drawshapepoly(m, plt, sf, lw=0.75, edgecolor='r', fillshape=False)

# set colorbar
plt.gcf().subplots_adjust(bottom=0.1)
cax = fig.add_axes([0.33,0.05,0.34,0.02]) # setup colorbar axes.
norm = colors.Normalize(vmin=b_min, vmax=b_max)
cb = colorbar.ColorbarBase(cax, cmap=cmap, norm=norm, orientation='horizontal', alpha=1.0)

# set cb labels
#linticks = array([0.01, 0.03, 0.1, 0.3 ])
ticks = arange(b_min, b_max+0.1, 0.1)
cb.set_ticks(ticks)
labels = [str('%0.1f' % x) for x in ticks]

#cb.set_ticklabels(labels, fontsize=10)
cb.ax.set_xticklabels(labels, fontsize=10)
cb.set_label('b-value', fontsize=12)

# set filename
plt.savefig('gridded_bval.png', format='png', dpi=300, bbox_inches='tight')
plt.show()

##########################################################################################
# write res file
##########################################################################################


txt = 'LON,LAT,B_RES\n'
for lo, la, br in zip (glons, glats, bdeg):
    txt += ','.join((str(lo), str(la), str(br))) + '\n'
    
f = open('gridded_bval_res.csv', 'w')
f.write(txt)
f.close()

txt = 'LON,LAT,BVAL,BSIG\n'
for lo, la, bv, bs, br in zip (glons, glats, bvals, bsig, bdeg):
    txt += ','.join((str(lo), str(la), str(bv), str(bs), str(bs))) + '\n'
    
f = open('gridded_bval.csv', 'w')
f.write(txt)
f.close()